// Code generated by protocol buffer compiler. Do not edit!
package gg.questnav.questnav.protos.generated;

import edu.wpi.first.math.proto.Geometry3D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;

public final class Data {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(7023,
        "CgpkYXRhLnByb3RvEhRxdWVzdG5hdi5wcm90b3MuZGF0YRoQZ2VvbWV0cnkzZC5wcm90byKNAQoZUHJv" + 
        "dG9idWZRdWVzdE5hdkZyYW1lRGF0YRIfCgtmcmFtZV9jb3VudBgBIAEoBVIKZnJhbWVDb3VudBIcCgl0" + 
        "aW1lc3RhbXAYAiABKAFSCXRpbWVzdGFtcBIxCgZwb3NlM2QYAyABKAsyGS53cGkucHJvdG8uUHJvdG9i" + 
        "dWZQb3NlM2RSBnBvc2UzZCKoAQoaUHJvdG9idWZRdWVzdE5hdkRldmljZURhdGESMgoVdHJhY2tpbmdf" + 
        "bG9zdF9jb3VudGVyGAEgASgFUhN0cmFja2luZ0xvc3RDb3VudGVyEi0KEmN1cnJlbnRseV90cmFja2lu" + 
        "ZxgCIAEoCFIRY3VycmVudGx5VHJhY2tpbmcSJwoPYmF0dGVyeV9wZXJjZW50GAMgASgFUg5iYXR0ZXJ5" + 
        "UGVyY2VudEJDCiVnZy5xdWVzdG5hdi5xdWVzdG5hdi5wcm90b3MuZ2VuZXJhdGVkqgIZUXVlc3ROYXYu" + 
        "UHJvdG9zLkdlbmVyYXRlZEqwMwoHEgUAA8ABAQoICgEMEgMAAxUK5AYKAQISAxYAHTLZBioKIFF1ZXN0" + 
        "TmF2IERhdGEgUHJvdG9jb2wgQnVmZmVyIERlZmluaXRpb25zCiAKIFRoaXMgZmlsZSBkZWZpbmVzIHRo" + 
        "ZSBkYXRhIHN0cnVjdHVyZXMgdXNlZCBmb3IgdHJhbnNtaXR0aW5nIHRyYWNraW5nIGFuZCBkZXZpY2UK" + 
        "IGluZm9ybWF0aW9uIGZyb20gdGhlIFF1ZXN0IGhlYWRzZXQgdG8gZXh0ZXJuYWwgc3lzdGVtcyAoc3Vj" + 
        "aCBhcyByb2JvdCBjb2RlKS4KIFRoZSBkYXRhIGlzIG9yZ2FuaXplZCBpbnRvIHR3byBtYWluIGNhdGVn" + 
        "b3JpZXMgd2l0aCBkaWZmZXJlbnQgdXBkYXRlIGZyZXF1ZW5jaWVzOgogCiAxLiBGcmFtZSBEYXRhOiBI" + 
        "aWdoLWZyZXF1ZW5jeSB0cmFja2luZyBpbmZvcm1hdGlvbiAocG9zZSwgdGltZXN0YW1wcykKIDIuIERl" + 
        "dmljZSBEYXRhOiBMb3dlci1mcmVxdWVuY3kgZGV2aWNlIHN0YXR1cyBpbmZvcm1hdGlvbiAoYmF0dGVy" + 
        "eSwgdHJhY2tpbmcgc3RhdGUpCiAKIFRoaXMgc2VwYXJhdGlvbiBhbGxvd3MgZm9yIGVmZmljaWVudCBi" + 
        "YW5kd2lkdGggdXNhZ2UgYnkgc2VuZGluZyBjcml0aWNhbCB0cmFja2luZwogZGF0YSBmcmVxdWVudGx5" + 
        "IHdoaWxlIHNlbmRpbmcgbGVzcyBjcml0aWNhbCBkZXZpY2Ugc3RhdHVzIGRhdGEgYXQgYSBsb3dlciBy" + 
        "YXRlLgogCiBEYXRhIEZsb3c6CiAtIFF1ZXN0IGNvbnRpbnVvdXNseSBwcm9jZXNzZXMgY2FtZXJhL3Nl" + 
        "bnNvciBkYXRhCiAtIEZyYW1lIGRhdGEgaXMgc2VudCBldmVyeSAxMCBtaWxsaXNlY29uZHMgKDEwMCBI",
        "eikKIC0gRGV2aWNlIGRhdGEgaXMgc2VudCBldmVyeSAzMzMgbWlsbGlzZWNvbmRzICgzIEh6KQogLSBF" + 
        "eHRlcm5hbCBzeXN0ZW1zIHJlY2VpdmUgYW5kIHByb2Nlc3MgdGhpcyBkYXRhIGZvciByb2JvdCBsb2Nh" + 
        "bGl6YXRpb24KCggKAQgSAxcANgoJCgIIJRIDFwA2CggKAQgSAxgAPgoJCgIIARIDGAA+Cj0KAgMAEgMb" + 
        "ABoaMiBJbXBvcnQgZ2VvbWV0cnkgbWVzc2FnZXMgZm9yIHBvc2UgcmVwcmVzZW50YXRpb24KCsAFCgIE" + 
        "ABIELQBpARqzBSoKIEhpZ2gtZnJlcXVlbmN5IHRyYWNraW5nIGRhdGEgc2VudCBmcm9tIFF1ZXN0IHRv" + 
        "IGV4dGVybmFsIHN5c3RlbXMuCiAKIFRoaXMgbWVzc2FnZSBjb250YWlucyB0aGUgY29yZSB0cmFja2lu" + 
        "ZyBpbmZvcm1hdGlvbiB0aGF0IGV4dGVybmFsIHN5c3RlbXMKIChsaWtlIHJvYm90IGNvZGUpIG5lZWQg" + 
        "Zm9yIHJlYWwtdGltZSBsb2NhbGl6YXRpb24gYW5kIG5hdmlnYXRpb24uIEl0J3Mgc2VudAogYXQgMTAw" + 
        "IEh6IChldmVyeSAxMCBtaWxsaXNlY29uZHMpIHRvIHByb3ZpZGUgc21vb3RoLCByZXNwb25zaXZlIHRy" + 
        "YWNraW5nLgogCiBUaGUgZGF0YSByZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uIGFuZCBvcmll" + 
        "bnRhdGlvbiBvbiB0aGUgZmllbGQsCiBkZXJpdmVkIGZyb20gdmlzdWFsLWluZXJ0aWFsIG9kb21ldHJ5" + 
        "IHVzaW5nIHRoZSBRdWVzdCdzIGNhbWVyYXMgYW5kIElNVSBzZW5zb3JzLgogCiBDb29yZGluYXRlIFN5" + 
        "c3RlbToKIC0gVXNlcyBXUElMaWIgZmllbGQtcmVsYXRpdmUgY29vcmRpbmF0ZSBzeXN0ZW0KIC0gT3Jp" + 
        "Z2luIGFuZCBheGVzIGRlcGVuZCBvbiBmaWVsZCBzZXR1cCBhbmQgY2FsaWJyYXRpb24KIC0gUG9zZSBy" + 
        "ZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uOyBtb3VudGluZyBvZmZzZXQgdG8gZ2V0IHJvYm90" + 
        "IHBvc2l0aW9uCiAgIGlzIGFwcGxpZWQgaW4gZW5kIHVzZXIgY29kZQoKCgoDBAABEgMtCCEKuAMKBAQA" + 
        "AgASAzsCGBqqAyoKIFNlcXVlbnRpYWwgZnJhbWUgY291bnRlciBmb3IgdGhpcyB0cmFja2luZyBzZXNz" + 
        "aW9uLgogCiBUaGlzIGNvdW50ZXIgaW5jcmVtZW50cyB3aXRoIGVhY2ggZnJhbWUgcHJvY2Vzc2VkIGJ5" + 
        "IHRoZSBRdWVzdCdzIHRyYWNraW5nCiBzeXN0ZW0uIEl0IGNhbiBiZSB1c2VkIHRvOgogLSBEZXRlY3Qg" + 
        "ZHJvcHBlZCBtZXNzYWdlcwogLSBDYWxjdWxhdGUgZWZmZWN0aXZlIGZyYW1lIHJhdGUKIC0gU3luY2hy",
        "b25pemUgd2l0aCBvdGhlciBkYXRhIHN0cmVhbXMKIAogVGhlIGNvdW50ZXIgcmVzZXRzIHRvIDAgd2hl" + 
        "biB0aGUgUXVlc3ROYXYgYXBwIHN0YXJ0cyBhbmQgaW5jcmVtZW50cwogY29udGludW91c2x5IGR1cmlu" + 
        "ZyBvcGVyYXRpb24uIEZyYW1lIGRyb3BzIGluIHRyYW5zbWlzc2lvbiB3aWxsIGNyZWF0ZQogZ2FwcyBp" + 
        "biB0aGUgc2VxdWVuY2UuCgoMCgUEAAIABRIDOwIHCgwKBQQAAgABEgM7CBMKDAoFBAACAAMSAzsWFwrf" + 
        "AwoEBAACARIDTAIXGtEDKgogVGltZXN0YW1wIGluIHNlY29uZHMgc2luY2UgUXVlc3ROYXYgYXBwIHN0" + 
        "YXJ0dXAuCiAKIFRoaXMgcHJvdmlkZXMgdGltaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgdHJhY2tpbmcg" + 
        "ZGF0YSwgYWxsb3dpbmcgZXh0ZXJuYWwKIHN5c3RlbXMgdG86CiAtIENhbGN1bGF0ZSBkYXRhIGFnZSBh" + 
        "bmQgbGF0ZW5jeQogLSBJbnRlcnBvbGF0ZSBvciBleHRyYXBvbGF0ZSBwb3NlcyBmb3IgcHJlZGljdGlv" + 
        "bgogLSBTeW5jaHJvbml6ZSB3aXRoIG90aGVyIHNlbnNvciBkYXRhCiAtIEltcGxlbWVudCB0aW1lb3V0" + 
        "IGRldGVjdGlvbgogCiBUaGUgdGltZXN0YW1wIGlzIHJlbGF0aXZlIHRvIGFwcCBzdGFydHVwLCBub3Qg" + 
        "c3lzdGVtIHRpbWUsIHRvIGF2b2lkCiBjbG9jayBzeW5jaHJvbml6YXRpb24gaXNzdWVzIGJldHdlZW4g" + 
        "ZGV2aWNlcy4KIAogUmVzb2x1dGlvbjogVHlwaWNhbGx5IHN1Yi1taWxsaXNlY29uZCBwcmVjaXNpb24K" + 
        "CgwKBQQAAgEFEgNMAggKDAoFBAACAQESA0wJEgoMCgUEAAIBAxIDTBUWCrUHCgQEAAICEgNoAiYapwcq" + 
        "CiBRdWVzdCdzIDNEIHBvc2Ugb24gdGhlIGZpZWxkIGluIFdQSUxpYiBjb29yZGluYXRlcy4KIAogVGhp" + 
        "cyByZXByZXNlbnRzIHRoZSBRdWVzdCdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBhcyBkZXRlcm1p" + 
        "bmVkIGJ5CiB0aGUgUXVlc3QncyB0cmFja2luZyBzeXN0ZW0uIFRoZSBwb3NlIGFjY291bnRzIGZvcjoK" + 
        "IC0gQ29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb24gdG8gV1BJTGliIHN0YW5kYXJkCiAtIEFu" + 
        "eSBjYWxpYnJhdGlvbiBvZmZzZXRzIGFwcGxpZWQKIAogTm90ZTogVGhpcyBpcyB0aGUgUXVlc3QncyBw" + 
        "b3NpdGlvbjsgZW5kIHVzZXIgY29kZSBhcHBsaWVzIG1vdW50aW5nIG9mZnNldAogdG8gZ2V0IHRoZSBy" + 
        "b2JvdCdzIHBvc2l0aW9uLgogCiBDb29yZGluYXRlIFN5c3RlbSBEZXRhaWxzOgogLSBYOiBGb3J3YXJk",
        "IGRpcmVjdGlvbiAodG93YXJkcyBvcHBvc2luZyBhbGxpYW5jZSkKIC0gWTogTGVmdCBkaXJlY3Rpb24g" + 
        "KHdoZW4gZmFjaW5nIGZvcndhcmQpCiAtIFo6IFVwIGRpcmVjdGlvbgogLSBZYXcgKFopOiBDb3VudGVy" + 
        "LWNsb2Nrd2lzZSAocmlnaHQtaGFuZGVkKSByb3RhdGlvbiBhcm91bmQgdGhlIFogYXhpcwogLSBQaXRj" + 
        "aCAoWSk6IENvdW50ZXItY2xvY2t3aXNlIChyaWdodC1oYW5kZWQpIHJvdGF0aW9uIGFyb3VuZCBZIGF4" + 
        "aXMKIC0gUm9sbCAoWCk6IENvdW50ZXItY2xvY2t3aXNlIChyaWdodC1oYW5kZWQpIHJvdGF0aW9uIGFy" + 
        "b3VuZCB0aGUgWCBheGlzCiAtIFVuaXRzOiBtZXRlcnMgZm9yIHRyYW5zbGF0aW9uLCByYWRpYW5zIGZv" + 
        "ciByb3RhdGlvbgogCiBBY2N1cmFjeSBkZXBlbmRzIG9uOgogLSBFbnZpcm9ubWVudGFsIGxpZ2h0aW5n" + 
        "IGFuZCBmZWF0dXJlcwogLSBRdWVzdCB0cmFja2luZyBxdWFsaXR5CiAtIENhbGlicmF0aW9uIGFjY3Vy" + 
        "YWN5CiAtIFRpbWUgc2luY2UgbGFzdCBwb3NlIHJlc2V0CgoMCgUEAAICBhIDaAIaCgwKBQQAAgIBEgNo" + 
        "GyEKDAoFBAACAgMSA2gkJQryBAoCBAESBXwAwAEBGuQEKgogTG93ZXItZnJlcXVlbmN5IGRldmljZSBz" + 
        "dGF0dXMgZGF0YSBzZW50IGZyb20gUXVlc3QgdG8gZXh0ZXJuYWwgc3lzdGVtcy4KIAogVGhpcyBtZXNz" + 
        "YWdlIGNvbnRhaW5zIGRldmljZSBoZWFsdGggYW5kIHN0YXR1cyBpbmZvcm1hdGlvbiB0aGF0IGRvZXNu" + 
        "J3QgbmVlZAogdG8gYmUgc2VudCBhcyBmcmVxdWVudGx5IGFzIHRyYWNraW5nIGRhdGEuIEl0J3Mgc2Vu" + 
        "dCBhdCAzIEh6IChldmVyeSAzMzMgbWlsbGlzZWNvbmRzKQogdG8gcHJvdmlkZSBtb25pdG9yaW5nIGFu" + 
        "ZCBkaWFnbm9zdGljIGluZm9ybWF0aW9uIHdpdGhvdXQgY29uc3VtaW5nIGV4Y2Vzc2l2ZQogYmFuZHdp" + 
        "ZHRoLgogCiBUaGlzIGRhdGEgaGVscHMgZXh0ZXJuYWwgc3lzdGVtczoKIC0gTW9uaXRvciBRdWVzdCBk" + 
        "ZXZpY2UgaGVhbHRoCiAtIERldGVjdCB0cmFja2luZyBzeXN0ZW0gaXNzdWVzCiAtIEltcGxlbWVudCBm" + 
        "YWlsc2FmZSBiZWhhdmlvcnMKIC0gUHJvdmlkZSB1c2VyIGZlZWRiYWNrIGFib3V0IHN5c3RlbSBzdGF0" + 
        "dXMKIAogVGhlIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCBmb3IgYm90aCBhdXRvbm9tb3VzIG9wZXJhdGlv" + 
        "biBhbmQgZGVidWdnaW5nLwogdHJvdWJsZXNob290aW5nIHNjZW5hcmlvcy4KCgoKAwQBARIDfAgiCoYF",
        "CgQEAQIAEgSQAQIiGvcEKgogQ291bnQgb2YgdHJhY2tpbmcgbG9zcyBldmVudHMgc2luY2UgYXBwIHN0" + 
        "YXJ0dXAuCiAKIFRoaXMgY291bnRlciBpbmNyZW1lbnRzIGVhY2ggdGltZSB0aGUgUXVlc3QncyB0cmFj" + 
        "a2luZyBzeXN0ZW0gbG9zZXMKIHRyYWNraW5nIGFmdGVyIGhhdmluZyBlc3RhYmxpc2hlZCBpdC4gVHJh" + 
        "Y2tpbmcgbG9zcyBjYW4gb2NjdXIgZHVlIHRvOgogLSBQb29yIGxpZ2h0aW5nIGNvbmRpdGlvbnMKIC0g" + 
        "TGFjayBvZiB2aXN1YWwgZmVhdHVyZXMgaW4gZW52aXJvbm1lbnQKIC0gUmFwaWQgbW90aW9uIG9yIGFj" + 
        "Y2VsZXJhdGlvbgogLSBPY2NsdXNpb24gb2YgY2FtZXJhcwogLSBIYXJkd2FyZSBpc3N1ZXMKIAogQSBo" + 
        "aWdoIG9yIHJhcGlkbHkgaW5jcmVhc2luZyBjb3VudGVyIG1heSBpbmRpY2F0ZToKIC0gRW52aXJvbm1l" + 
        "bnRhbCBpc3N1ZXMgKGxpZ2h0aW5nLCBmZWF0dXJlcykKIC0gUXVlc3QgbW91bnRpbmcgcHJvYmxlbXMg" + 
        "KHZpYnJhdGlvbiwgb2JzdHJ1Y3Rpb24pCiAtIEhhcmR3YXJlIGRlZ3JhZGF0aW9uCiAKIFRoaXMgbWV0" + 
        "cmljIGhlbHBzIGFzc2VzcyB0cmFja2luZyBzeXN0ZW0gcmVsaWFiaWxpdHkgYW5kIGNhbiB0cmlnZ2Vy" + 
        "CiBhbGVydHMgb3IgZmFsbGJhY2sgYmVoYXZpb3JzIGluIHJvYm90IGNvZGUuCgoNCgUEAQIABRIEkAEC" + 
        "BwoNCgUEAQIAARIEkAEIHQoNCgUEAQIAAxIEkAEgIQq6BQoEBAECARIEpgECHhqrBSoKIEN1cnJlbnQg" + 
        "dHJhY2tpbmcgc3RhdHVzIG9mIHRoZSBRdWVzdCBkZXZpY2UuCiAKIHRydWU6ICBRdWVzdCBpcyBhY3Rp" + 
        "dmVseSB0cmFja2luZyBhbmQgcG9zZSBkYXRhIGlzIHJlbGlhYmxlCiBmYWxzZTogUXVlc3QgaGFzIGxv" + 
        "c3QgdHJhY2tpbmcgYW5kIHBvc2UgZGF0YSBzaG91bGQgbm90IGJlIHRydXN0ZWQKIAogV2hlbiB0cmFj" + 
        "a2luZyBpcyBsb3N0OgogLSBQb3NlIGRhdGEgYmVjb21lcyBzdGFsZSBhbmQgdW5yZWxpYWJsZQogLSBS" + 
        "b2JvdCBzaG91bGQgc3dpdGNoIHRvIGFsdGVybmF0aXZlIGxvY2FsaXphdGlvbiBtZXRob2RzCiAtIE1v" + 
        "dmVtZW50IHNob3VsZCBiZSBsaW1pdGVkIG9yIHN0b3BwZWQgZm9yIHNhZmV0eQogCiBUcmFja2luZyBj" + 
        "YW4gYmUgcmVjb3ZlcmVkIGJ5OgogLSBJbXByb3ZpbmcgbGlnaHRpbmcgY29uZGl0aW9ucwogLSBNb3Zp" + 
        "bmcgdG8gYXJlYSB3aXRoIG1vcmUgdmlzdWFsIGZlYXR1cmVzCiAtIFJlZHVjaW5nIG1vdGlvbiB0byBh",
        "bGxvdyBzeXN0ZW0gdG8gcmUtaW5pdGlhbGl6ZQogLSBQZXJmb3JtaW5nIHBvc2UgcmVzZXQgd2hlbiB0" + 
        "cmFja2luZyByZWNvdmVycwogCiBFeHRlcm5hbCBzeXN0ZW1zIHNob3VsZCBtb25pdG9yIHRoaXMgZmll" + 
        "bGQgYW5kIGltcGxlbWVudCBhcHByb3ByaWF0ZQogZmFsbGJhY2sgYmVoYXZpb3JzIHdoZW4gdHJhY2tp" + 
        "bmcgaXMgbG9zdC4KCg0KBQQBAgEFEgSmAQIGCg0KBQQBAgEBEgSmAQcZCg0KBQQBAgEDEgSmARwdCtoF" + 
        "CgQEAQICEgS/AQIcGssFKgogUXVlc3QgZGV2aWNlIGJhdHRlcnkgbGV2ZWwgYXMgYSBwZXJjZW50YWdl" + 
        "ICgwLTEwMCkuCiAKIFRoaXMgcHJvdmlkZXMgdGhlIGN1cnJlbnQgYmF0dGVyeSBjaGFyZ2UgbGV2ZWwg" + 
        "b2YgdGhlIFF1ZXN0IGhlYWRzZXQsCiBhbGxvd2luZyBleHRlcm5hbCBzeXN0ZW1zIHRvOgogLSBNb25p" + 
        "dG9yIHBvd2VyIHN0YXR1cyBkdXJpbmcgb3BlcmF0aW9uCiAtIEltcGxlbWVudCBsb3ctYmF0dGVyeSB3" + 
        "YXJuaW5ncyBvciBiZWhhdmlvcnMKIC0gUGxhbiBvcGVyYXRpb24gZHVyYXRpb24gYW5kIGNoYXJnaW5n" + 
        "IG5lZWRzCiAtIFRyaWdnZXIgZ3JhY2VmdWwgc2h1dGRvd24gcHJvY2VkdXJlcwogCiBCYXR0ZXJ5IExl" + 
        "dmVsIEd1aWRlbGluZXM6CiAtIDEwMCU6IEZ1bGx5IGNoYXJnZWQKIC0gNTAtMTAwJTogTm9ybWFsIG9w" + 
        "ZXJhdGlvbgogLSAyMC01MCU6IENvbnNpZGVyIGNoYXJnaW5nIHNvb24KIC0gMTAtMjAlOiBMb3cgYmF0" + 
        "dGVyeSB3YXJuaW5nIHJlY29tbWVuZGVkCiAtIDAtMTAlOiBDcml0aWNhbCAtIHBsYW4gaW1tZWRpYXRl" + 
        "IHNodXRkb3duL2NoYXJnaW5nCiAKIE5vdGU6IEJhdHRlcnkgZHJhaW4gcmF0ZSBkZXBlbmRzIG9uOgog" + 
        "LSBQcm9jZXNzaW5nIGxvYWQgKHRyYWNraW5nIGNvbXBsZXhpdHkpCiAtIERpc3BsYXkgdXNhZ2UgKGlm" + 
        "IGFueSkKIC0gV2lyZWxlc3MgY29tbXVuaWNhdGlvbiBhY3Rpdml0eQogLSBFbnZpcm9ubWVudGFsIHRl" + 
        "bXBlcmF0dXJlCgoNCgUEAQICBRIEvwECBwoNCgUEAQICARIEvwEIFwoNCgUEAQICAxIEvwEaG2IGcHJv" + 
        "dG8z");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("data.proto", "questnav.protos.data", descriptorData, Geometry3D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavFrameData_descriptor = descriptor.internalContainedType(55, 141, "ProtobufQuestNavFrameData", "questnav.protos.data.ProtobufQuestNavFrameData");

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavDeviceData_descriptor = descriptor.internalContainedType(199, 168, "ProtobufQuestNavDeviceData", "questnav.protos.data.ProtobufQuestNavDeviceData");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     * *
     *  High-frequency tracking data sent from Quest to external systems.
     *  
     *  This message contains the core tracking information that external systems
     *  (like robot code) need for real-time localization and navigation. It's sent
     *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
     *  
     *  The data represents the Quest's position and orientation on the field,
     *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - Origin and axes depend on field setup and calibration
     *  - Pose represents the Quest's position; mounting offset to get robot position
     *    is applied in end user code
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavFrameData}
     */
    public static final class ProtobufQuestNavFrameData extends ProtoMessage<ProtobufQuestNavFrameData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         */
        private double timestamp;

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         */
        private int frameCount;

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         */
        private final Geometry3D.ProtobufPose3d pose3D = Geometry3D.ProtobufPose3d.newInstance();

        private ProtobufQuestNavFrameData() {
        }

        /**
         * <pre>
         * *
         *  High-frequency tracking data sent from Quest to external systems.
         *  
         *  This message contains the core tracking information that external systems
         *  (like robot code) need for real-time localization and navigation. It's sent
         *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
         *  
         *  The data represents the Quest's position and orientation on the field,
         *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - Origin and axes depend on field setup and calibration
         *  - Pose represents the Quest's position; mounting offset to get robot position
         *    is applied in end user code
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavFrameData}
         */
        public static ProtobufQuestNavFrameData newInstance() {
            return new ProtobufQuestNavFrameData();
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return whether the timestamp field is set
         */
        public boolean hasTimestamp() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearTimestamp() {
            bitField0_ &= ~0x00000001;
            timestamp = 0D;
            return this;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return the timestamp
         */
        public double getTimestamp() {
            return timestamp;
        }

        /**
         * <pre>
         * *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @param value the timestamp to set
         * @return this
         */
        public ProtobufQuestNavFrameData setTimestamp(final double value) {
            bitField0_ |= 0x00000001;
            timestamp = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return whether the frameCount field is set
         */
        public boolean hasFrameCount() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearFrameCount() {
            bitField0_ &= ~0x00000002;
            frameCount = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return the frameCount
         */
        public int getFrameCount() {
            return frameCount;
        }

        /**
         * <pre>
         * *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @param value the frameCount to set
         * @return this
         */
        public ProtobufQuestNavFrameData setFrameCount(final int value) {
            bitField0_ |= 0x00000002;
            frameCount = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @return whether the pose3D field is set
         */
        public boolean hasPose3D() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearPose3D() {
            bitField0_ &= ~0x00000004;
            pose3D.clear();
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePose3D()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry3D.ProtobufPose3d getPose3D() {
            return pose3D;
        }

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry3D.ProtobufPose3d getMutablePose3D() {
            bitField0_ |= 0x00000004;
            return pose3D;
        }

        /**
         * <pre>
         * *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @param value the pose3D to set
         * @return this
         */
        public ProtobufQuestNavFrameData setPose3D(final Geometry3D.ProtobufPose3d value) {
            bitField0_ |= 0x00000004;
            pose3D.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData copyFrom(final ProtobufQuestNavFrameData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                timestamp = other.timestamp;
                frameCount = other.frameCount;
                pose3D.copyFrom(other.pose3D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final ProtobufQuestNavFrameData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTimestamp()) {
                setTimestamp(other.timestamp);
            }
            if (other.hasFrameCount()) {
                setFrameCount(other.frameCount);
            }
            if (other.hasPose3D()) {
                getMutablePose3D().mergeFrom(other.pose3D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            timestamp = 0D;
            frameCount = 0;
            pose3D.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            pose3D.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavFrameData)) {
                return false;
            }
            ProtobufQuestNavFrameData other = (ProtobufQuestNavFrameData) o;
            return bitField0_ == other.bitField0_
                && (!hasTimestamp() || ProtoUtil.isEqual(timestamp, other.timestamp))
                && (!hasFrameCount() || frameCount == other.frameCount)
                && (!hasPose3D() || pose3D.equals(other.pose3D));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 17);
                output.writeDoubleNoTag(timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeMessageNoTag(pose3D);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 9;
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(pose3D);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavFrameData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 17: {
                        // timestamp
                        timestamp = input.readDouble();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // frameCount
                        frameCount = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // pose3D
                        input.readMessage(pose3D);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeDouble(FieldNames.timestamp, timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.frameCount, frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeMessage(FieldNames.pose3D, pose3D);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 55126294: {
                        if (input.isAtField(FieldNames.timestamp)) {
                            if (!input.trySkipNullValue()) {
                                timestamp = input.readDouble();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -296512606:
                    case 188405693: {
                        if (input.isAtField(FieldNames.frameCount)) {
                            if (!input.trySkipNullValue()) {
                                frameCount = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -982466846: {
                        if (input.isAtField(FieldNames.pose3D)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(pose3D);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clone() {
            return new ProtobufQuestNavFrameData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavFrameData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), data).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavFrameData messages
         */
        public static MessageFactory<ProtobufQuestNavFrameData> getFactory() {
            return ProtobufQuestNavFrameDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavFrameData_descriptor;
        }

        private enum ProtobufQuestNavFrameDataFactory implements MessageFactory<ProtobufQuestNavFrameData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavFrameData create() {
                return ProtobufQuestNavFrameData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName timestamp = FieldName.forField("timestamp");

            static final FieldName frameCount = FieldName.forField("frameCount", "frame_count");

            static final FieldName pose3D = FieldName.forField("pose3d");
        }
    }

    /**
     * <pre>
     * *
     *  Lower-frequency device status data sent from Quest to external systems.
     *  
     *  This message contains device health and status information that doesn't need
     *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
     *  to provide monitoring and diagnostic information without consuming excessive
     *  bandwidth.
     *  
     *  This data helps external systems:
     *  - Monitor Quest device health
     *  - Detect tracking system issues
     *  - Implement failsafe behaviors
     *  - Provide user feedback about system status
     *  
     *  The information is useful for both autonomous operation and debugging/
     *  troubleshooting scenarios.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavDeviceData}
     */
    public static final class ProtobufQuestNavDeviceData extends ProtoMessage<ProtobufQuestNavDeviceData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         */
        private int trackingLostCounter;

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         */
        private int batteryPercent;

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         */
        private boolean currentlyTracking;

        private ProtobufQuestNavDeviceData() {
        }

        /**
         * <pre>
         * *
         *  Lower-frequency device status data sent from Quest to external systems.
         *  
         *  This message contains device health and status information that doesn't need
         *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
         *  to provide monitoring and diagnostic information without consuming excessive
         *  bandwidth.
         *  
         *  This data helps external systems:
         *  - Monitor Quest device health
         *  - Detect tracking system issues
         *  - Implement failsafe behaviors
         *  - Provide user feedback about system status
         *  
         *  The information is useful for both autonomous operation and debugging/
         *  troubleshooting scenarios.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavDeviceData}
         */
        public static ProtobufQuestNavDeviceData newInstance() {
            return new ProtobufQuestNavDeviceData();
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return whether the trackingLostCounter field is set
         */
        public boolean hasTrackingLostCounter() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearTrackingLostCounter() {
            bitField0_ &= ~0x00000001;
            trackingLostCounter = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return the trackingLostCounter
         */
        public int getTrackingLostCounter() {
            return trackingLostCounter;
        }

        /**
         * <pre>
         * *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @param value the trackingLostCounter to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setTrackingLostCounter(final int value) {
            bitField0_ |= 0x00000001;
            trackingLostCounter = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return whether the batteryPercent field is set
         */
        public boolean hasBatteryPercent() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearBatteryPercent() {
            bitField0_ &= ~0x00000002;
            batteryPercent = 0;
            return this;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return the batteryPercent
         */
        public int getBatteryPercent() {
            return batteryPercent;
        }

        /**
         * <pre>
         * *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @param value the batteryPercent to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setBatteryPercent(final int value) {
            bitField0_ |= 0x00000002;
            batteryPercent = value;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return whether the currentlyTracking field is set
         */
        public boolean hasCurrentlyTracking() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearCurrentlyTracking() {
            bitField0_ &= ~0x00000004;
            currentlyTracking = false;
            return this;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return the currentlyTracking
         */
        public boolean getCurrentlyTracking() {
            return currentlyTracking;
        }

        /**
         * <pre>
         * *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @param value the currentlyTracking to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setCurrentlyTracking(final boolean value) {
            bitField0_ |= 0x00000004;
            currentlyTracking = value;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData copyFrom(final ProtobufQuestNavDeviceData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                trackingLostCounter = other.trackingLostCounter;
                batteryPercent = other.batteryPercent;
                currentlyTracking = other.currentlyTracking;
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final ProtobufQuestNavDeviceData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTrackingLostCounter()) {
                setTrackingLostCounter(other.trackingLostCounter);
            }
            if (other.hasBatteryPercent()) {
                setBatteryPercent(other.batteryPercent);
            }
            if (other.hasCurrentlyTracking()) {
                setCurrentlyTracking(other.currentlyTracking);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            trackingLostCounter = 0;
            batteryPercent = 0;
            currentlyTracking = false;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavDeviceData)) {
                return false;
            }
            ProtobufQuestNavDeviceData other = (ProtobufQuestNavDeviceData) o;
            return bitField0_ == other.bitField0_
                && (!hasTrackingLostCounter() || trackingLostCounter == other.trackingLostCounter)
                && (!hasBatteryPercent() || batteryPercent == other.batteryPercent)
                && (!hasCurrentlyTracking() || currentlyTracking == other.currentlyTracking);
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 24);
                output.writeInt32NoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(currentlyTracking);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 2;
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavDeviceData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // trackingLostCounter
                        trackingLostCounter = input.readInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // batteryPercent
                        batteryPercent = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // currentlyTracking
                        currentlyTracking = input.readBool();
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeInt32(FieldNames.trackingLostCounter, trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.batteryPercent, batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeBool(FieldNames.currentlyTracking, currentlyTracking);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1237870847:
                    case -2011984791: {
                        if (input.isAtField(FieldNames.trackingLostCounter)) {
                            if (!input.trySkipNullValue()) {
                                trackingLostCounter = input.readInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -2041653896:
                    case -1975165933: {
                        if (input.isAtField(FieldNames.batteryPercent)) {
                            if (!input.trySkipNullValue()) {
                                batteryPercent = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 879013277:
                    case 106200592: {
                        if (input.isAtField(FieldNames.currentlyTracking)) {
                            if (!input.trySkipNullValue()) {
                                currentlyTracking = input.readBool();
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clone() {
            return new ProtobufQuestNavDeviceData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavDeviceData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), data).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavDeviceData messages
         */
        public static MessageFactory<ProtobufQuestNavDeviceData> getFactory() {
            return ProtobufQuestNavDeviceDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavDeviceData_descriptor;
        }

        private enum ProtobufQuestNavDeviceDataFactory implements MessageFactory<ProtobufQuestNavDeviceData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavDeviceData create() {
                return ProtobufQuestNavDeviceData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName trackingLostCounter = FieldName.forField("trackingLostCounter", "tracking_lost_counter");

            static final FieldName batteryPercent = FieldName.forField("batteryPercent", "battery_percent");

            static final FieldName currentlyTracking = FieldName.forField("currentlyTracking", "currently_tracking");
        }
    }
}
